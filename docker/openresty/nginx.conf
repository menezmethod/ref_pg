# nginx.conf - Simple configuration for URL shortener with OpenResty
#
# This file is based on the official OpenResty Docker examples
# and should be modified according to your needs.
#

worker_processes auto;
error_log /dev/stderr notice;
pid /var/run/nginx.pid;

# Load modules
load_module modules/ngx_http_lua_module.so;

events {
    worker_connections 1024;
}

http {
    include mime.types;
    default_type text/html;

    # Log to stdout for Docker
    access_log /dev/stdout combined;
    error_log /dev/stderr notice;

    # Optimize sendfile
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    # Set buffer sizes
    client_body_buffer_size 10k;
    client_header_buffer_size 1k;
    client_max_body_size 8m;
    large_client_header_buffers 2 1k;

    # Gzip compression
    gzip on;
    gzip_disable "msie6";
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_buffers 16 8k;
    gzip_http_version 1.1;
    gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;

    # Rate limiting zones
    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=${RATE_LIMIT_REQUESTS}r/m;
    limit_req_status 429;

    # We need a resolver for using variables in proxy_pass
    resolver 127.0.0.11 ipv6=off;

    # Define servers here
    server {
        listen 80;
        server_name localhost;

        # Basic security headers
        add_header X-Content-Type-Options nosniff;
        add_header X-Frame-Options SAMEORIGIN;
        add_header X-XSS-Protection "1; mode=block";
        add_header Referrer-Policy strict-origin-when-cross-origin;

        # Home page
        location / {
            default_type text/html;
            return 200 '<html><body><h1>URL Shortener Service</h1><p>Use /r/{code} to access short links</p></body></html>';
        }

        # API passthrough
        location /api/ {
            # Apply rate limiting
            limit_req zone=api_limit burst=20 nodelay;
            
            proxy_pass http://postgrest:3000/;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Add CORS headers
            add_header 'Access-Control-Allow-Origin' '*' always;
            add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, PUT, DELETE, PATCH' always;
            add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization' always;
            add_header 'Access-Control-Expose-Headers' 'Content-Length,Content-Range' always;
            
            # Handle preflight requests
            if ($request_method = 'OPTIONS') {
                add_header 'Access-Control-Allow-Origin' '*';
                add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, PUT, DELETE, PATCH';
                add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization';
                add_header 'Access-Control-Max-Age' 1728000;
                add_header 'Content-Type' 'text/plain; charset=utf-8';
                add_header 'Content-Length' 0;
                return 204;
            }
        }

        # URL shortener redirect with rate limiting
        location ~ ^/r/(.+) {
            # Apply more lenient rate limiting for redirects
            limit_req zone=api_limit burst=30 nodelay;
            
            set $code $1;
            set $postgrest_api "http://postgrest:3000";
            default_type text/html;

            # If we can't connect to the API, show an error
            error_page 502 504 = @api_error;
            
            # Access the API directly using lua to retrieve the URL
            content_by_lua_block {
                local cjson = require "cjson"
                local http = require "resty.http"
                
                local httpc = http.new()
                httpc:set_timeout(5000)  -- 5 seconds timeout
                
                -- Debug log
                local debug_file = io.open("/tmp/debug.log", "a")
                if debug_file then
                    debug_file:write("Attempting to connect to API for code: " .. ngx.var.code .. "\n")
                end
                
                -- Make the API request to get the original URL
                local res, err = httpc:request_uri(
                    ngx.var.postgrest_api .. "/rpc/get_original_url",
                    {
                        method = "POST",
                        body = cjson.encode({ p_code = ngx.var.code }),
                        headers = {
                            ["Content-Type"] = "application/json"
                        }
                    }
                )
                
                -- Error handling
                if not res then
                    if debug_file then
                        debug_file:write("Error connecting to API: " .. (err or "unknown error") .. "\n")
                        debug_file:close()
                    end
                    ngx.status = 500
                    ngx.say("Error connecting to redirect service: " .. (err or "unknown error"))
                    return
                end
                
                -- Process response
                if res.status == 200 then
                    local url = cjson.decode(res.body)
                    
                    if debug_file then
                        debug_file:write("API response: " .. (res.body or "empty") .. "\n")
                        debug_file:write("Parsed URL: " .. (url or "null") .. "\n")
                        debug_file:close()
                    end
                    
                    if url and url ~= cjson.null then
                        -- If the response is a JSON string (starts and ends with quotes),
                        -- we need to remove the quotes
                        if type(url) == "string" then
                            url = url:gsub('^"', ''):gsub('"$', '')
                        end
                        
                        -- Track click before redirecting (non-blocking)
                        pcall(function()
                            httpc:request_uri(
                                ngx.var.postgrest_api .. "/rpc/track_link_click",
                                {
                                    method = "POST",
                                    body = cjson.encode({ 
                                        p_code = ngx.var.code,
                                        p_ip_address = ngx.var.remote_addr,
                                        p_user_agent = ngx.var.http_user_agent,
                                        p_referrer = ngx.var.http_referer
                                    }),
                                    headers = {
                                        ["Content-Type"] = "application/json"
                                    }
                                }
                            )
                        end)
                        
                        ngx.redirect(url, 302)
                    else
                        ngx.status = 404
                        ngx.say("Short link not found or expired")
                    end
                else
                    if debug_file then
                        debug_file:write("API error: status " .. res.status .. "\n")
                        debug_file:write("Response: " .. (res.body or "empty") .. "\n")
                        debug_file:close()
                    end
                    
                    ngx.status = res.status
                    ngx.say("Error retrieving short link: " .. (res.body or "unknown error"))
                end
            }
        }
        
        # Error handler for API errors
        location @api_error {
            return 500 '<html><body><h1>Service Unavailable</h1><p>The URL shortener service is temporarily unavailable. Please try again later.</p></body></html>';
        }
        
        # Health check endpoint
        location /health {
            access_log off;
            return 200 "healthy\n";
        }
    }
} 